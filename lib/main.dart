// lib/main.dart

import 'package:flutter/material.dart';

// UI + domain + data imports
import 'src/ui/login_screen_custom.dart';
import 'src/domain/login_controller.dart';
import 'src/data/auth_repository.dart';
import 'src/domain/models.dart';

// Firebase imports
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart'; // generated by flutterfire CLI (if available)

// The concrete Firebase repo implementation (if you added it)
import 'src/data/firebase_auth_repository.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  LoginController controller;

  // Try to initialize Firebase and use the real repo.
  // If anything fails (missing firebase_options, CLI not run, wrong config),
  // fall back to MockRepo so you can continue testing UI.
  try {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    // If the FirebaseAuthRepository file exists and is correct, use it.
    controller = LoginController(repo: FirebaseAuthRepository());
    debugPrint('Using FirebaseAuthRepository (Firebase initialized).');
  } catch (e, st) {
    debugPrint('Firebase initialization failed â€” falling back to MockRepo.');
    debugPrint('Firebase init error: $e\n$st');
    controller = LoginController(repo: MockRepo());
  }

  runApp(MyApp(controller: controller));
}

class MyApp extends StatelessWidget {
  final LoginController controller;

  const MyApp({super.key, required this.controller});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Login Demo',
      debugShowCheckedModeBanner: false,
      home: LoginScreenCustom(controller: controller),
    );
  }
}

/// Temporary mock backend implementation.
/// Keeps UI testable before full backend is wired.
class MockRepo implements AuthRepository {
  @override
  Future<bool> requestEmailOtp(String email) async {
    await Future.delayed(const Duration(milliseconds: 500));
    return true; // always succeed (mock)
  }

  @override
  Future<AuthResult> verifyEmailOtp(String email, String otp) async {
    await Future.delayed(const Duration(milliseconds: 500));
    if (otp == "123456") {
      return AuthSuccess(uid: "1", email: email);
    }
    return AuthFailure("Invalid OTP");
  }

  @override
  Future<AuthResult> signInWithEmail(String email, String password) async {
    // Always succeed for testing
    return AuthSuccess(uid: "1", email: email);
  }

  @override
  Future<AuthResult> signUpWithEmail(String email, String password) async {
    // Mock sign-up simply returns success
    return AuthSuccess(uid: "new_user", email: email);
  }

  @override
  Future<AuthResult> signInWithOAuthCredential(String provider, String token) async {
    // Mock OAuth always succeeds
    return AuthSuccess(uid: "$provider-user", email: "$provider@example.com");
  }

  @override
  Future<void> signOut() async {
    // no-op in mock
  }
}
